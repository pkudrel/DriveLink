import { Platform } from 'obsidian';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

/**
 * SimpleToken CLI integration for DriveLink plugin
 * Provides seamless access to credentials and tokens generated by SimpleToken CLI
 */

interface SimpleTokenCredentials {
    clientId: string;
    clientSecret: string;
    savedAt: string;
}

interface SimpleTokens {
    accessToken: string;
    refreshToken?: string;
    expiresIn?: number;
    tokenType: string;
    scope?: string;
    savedAt: string;
    expiresAt?: string;
    version: string;
}

interface TokenData {
    accessToken: string;
    refreshToken?: string;
    expiresAt: number;
    tokenType: string;
    scope: string;
}

/**
 * Bridge class for integrating with SimpleToken CLI storage
 */
export class SimpleTokenBridge {
    private static readonly CREDENTIALS_DIR = path.join(os.homedir(), '.drivelink');
    private static readonly CREDENTIALS_FILE = path.join(SimpleTokenBridge.CREDENTIALS_DIR, 'credentials.json');
    private static readonly TOKENS_FILE = path.join(SimpleTokenBridge.CREDENTIALS_DIR, 'tokens.json');
    private static readonly OBFUSCATION_KEY = 'drivelink-simple-token-key';

    /**
     * Check if SimpleToken CLI storage exists
     */
    static hasSimpleTokenStorage(): boolean {
        try {
            return fs.existsSync(this.CREDENTIALS_DIR) &&
                   (fs.existsSync(this.CREDENTIALS_FILE) || fs.existsSync(this.TOKENS_FILE));
        } catch {
            return false;
        }
    }

    /**
     * Check if credentials are available from SimpleToken CLI
     */
    static hasCredentials(): boolean {
        try {
            return fs.existsSync(this.CREDENTIALS_FILE);
        } catch {
            return false;
        }
    }

    /**
     * Check if tokens are available from SimpleToken CLI
     */
    static hasTokens(): boolean {
        try {
            return fs.existsSync(this.TOKENS_FILE);
        } catch {
            return false;
        }
    }

    /**
     * Deobfuscate SimpleToken CLI stored data
     */
    private static deobfuscate(obfuscatedData: string): string {
        try {
            const keyBuffer = Buffer.from(this.OBFUSCATION_KEY, 'utf8');
            const dataBuffer = Buffer.from(obfuscatedData, 'base64');
            const result = Buffer.alloc(dataBuffer.length);

            for (let i = 0; i < dataBuffer.length; i++) {
                result[i] = dataBuffer[i] ^ keyBuffer[i % keyBuffer.length];
            }

            return result.toString('utf8');
        } catch (error) {
            throw new Error('Failed to deobfuscate SimpleToken data - may be corrupted');
        }
    }

    /**
     * Load credentials from SimpleToken CLI storage
     */
    static async loadCredentials(): Promise<SimpleTokenCredentials | null> {
        try {
            if (!fs.existsSync(this.CREDENTIALS_FILE)) {
                return null;
            }

            const obfuscatedData = fs.readFileSync(this.CREDENTIALS_FILE, 'utf8');
            const credentialsJson = this.deobfuscate(obfuscatedData);
            const credentials = JSON.parse(credentialsJson);

            // Validate structure
            if (!credentials.clientId || !credentials.clientSecret) {
                console.warn('SimpleToken: Invalid credentials structure');
                return null;
            }

            return {
                clientId: credentials.clientId,
                clientSecret: credentials.clientSecret,
                savedAt: credentials.savedAt
            };

        } catch (error) {
            console.error('SimpleToken: Failed to load credentials:', error.message);
            return null;
        }
    }

    /**
     * Load tokens from SimpleToken CLI storage
     */
    static async loadTokens(): Promise<SimpleTokens | null> {
        try {
            if (!fs.existsSync(this.TOKENS_FILE)) {
                return null;
            }

            const obfuscatedData = fs.readFileSync(this.TOKENS_FILE, 'utf8');
            const tokensJson = this.deobfuscate(obfuscatedData);
            const tokens = JSON.parse(tokensJson);

            // Validate structure
            if (!tokens.accessToken) {
                console.warn('SimpleToken: Invalid tokens structure');
                return null;
            }

            return tokens;

        } catch (error) {
            console.error('SimpleToken: Failed to load tokens:', error.message);
            return null;
        }
    }

    /**
     * Convert SimpleToken format to plugin TokenData format
     */
    static convertToTokenData(simpleTokens: SimpleTokens): TokenData | null {
        try {
            if (!simpleTokens.accessToken) {
                return null;
            }

            // Calculate expiry timestamp
            let expiresAt: number;
            if (simpleTokens.expiresAt) {
                expiresAt = new Date(simpleTokens.expiresAt).getTime();
            } else if (simpleTokens.expiresIn) {
                // Fallback: use current time + expires_in
                expiresAt = Date.now() + (simpleTokens.expiresIn * 1000);
            } else {
                // Default: assume 1 hour expiry
                expiresAt = Date.now() + (60 * 60 * 1000);
            }

            return {
                accessToken: simpleTokens.accessToken,
                refreshToken: simpleTokens.refreshToken,
                expiresAt,
                tokenType: simpleTokens.tokenType || 'Bearer',
                scope: simpleTokens.scope || 'https://www.googleapis.com/auth/drive'
            };

        } catch (error) {
            console.error('SimpleToken: Failed to convert token data:', error.message);
            return null;
        }
    }

    /**
     * Check if SimpleToken tokens are valid and not expired
     */
    static async validateTokens(): Promise<boolean> {
        try {
            const tokens = await this.loadTokens();
            if (!tokens || !tokens.accessToken) {
                return false;
            }

            // Check expiry
            if (tokens.expiresAt) {
                const expiresAt = new Date(tokens.expiresAt);
                const now = new Date();

                // Add 5-minute buffer for safety
                const bufferMs = 5 * 60 * 1000;
                if (now.getTime() >= (expiresAt.getTime() - bufferMs)) {
                    return false;
                }
            }

            return true;
        } catch {
            return false;
        }
    }

    /**
     * Get SimpleToken CLI integration status for UI display
     */
    static async getIntegrationStatus(): Promise<{
        available: boolean;
        hasCredentials: boolean;
        hasTokens: boolean;
        tokensValid: boolean;
        storageLocation: string;
    }> {
        const available = this.hasSimpleTokenStorage();
        const hasCredentials = this.hasCredentials();
        const hasTokens = this.hasTokens();
        const tokensValid = await this.validateTokens();

        return {
            available,
            hasCredentials,
            hasTokens,
            tokensValid,
            storageLocation: this.CREDENTIALS_DIR
        };
    }

    /**
     * Get ready-to-use TokenData from SimpleToken CLI if available
     */
    static async getTokenDataFromSimpleToken(): Promise<TokenData | null> {
        try {
            const tokens = await this.loadTokens();
            if (!tokens) {
                return null;
            }

            return this.convertToTokenData(tokens);
        } catch (error) {
            console.error('SimpleToken: Failed to get token data:', error.message);
            return null;
        }
    }

    /**
     * Platform-specific path helpers
     */
    static getCredentialsPath(): string {
        return this.CREDENTIALS_FILE;
    }

    static getTokensPath(): string {
        return this.TOKENS_FILE;
    }

    static getStorageDirectory(): string {
        return this.CREDENTIALS_DIR;
    }
}